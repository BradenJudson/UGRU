}
#call a function that takes no arguments
test_func() #the function is run on this line.
test_func = function(){
return("I'm a function, just doing my thing.")
}
#call a function that takes no arguments
test_func() #the function is run on this line.
y = test_func()
toupper(y)
test_maths = function(x){
output = x * 5
return(output)
}
test_maths()#need to pass an argument!
test_maths(25)
y = 7
test_maths(y)
print(paste("After the function call, the value of y is:", y))
y = 7
y = test_maths(y)
y
test_maths = function(x = 99){
output = x * 5
return(output)
}
test_maths()#no value passed for argument x, so it runs with the default.
algebra_ex = function(x, y){
print(paste("x is:", x))
print(paste("y is:", y))
output = x*(x+y)
return(output)
}
algebra_ex(x=6, y=7)
algebra_ex = function(longname_x, y){
print(paste("longname_x is:", longname_x))
print(paste("y is:", y))
output = longname_x*(longname_x+y)
return(output)
}
algebra_ex(y=7, l=6) #don't need to type all of longname_x
algebra_ex = function(longname_x, y){
print(paste("longname_x is:", longname_x))
print(paste("y is:", y))
output = longname_x*(longname_x+y)
return(output)
}
algebra_ex(y=7, l=6) #don't need to type all of longname_x
algebra_ex = function(longname_x, y){
print(paste("longname_x is:", longname_x))
print(paste("y is:", y))
output = longname_x*(longname_x+y)
return(output)
}
algebra_ex(y=7, 6) #don't need to type all of longname_x
#positional inference of arguments
lm(Sepal.Length~Sepal.Width , iris)
#abbreviation
lm(Sepal.Length~Sepal.Width , d = iris)
lm
maths = function(x, y){
z = x * y * y * 3
return(z)
}
maths(3, 6)
how_long_to_x = function(less_than = 5, range = 25, max = 20){
#for the given number of times
for(i in 1:max){
#get a random number
new_num = sample(1:range, 1)
#check if it is less than the cutoff
if(new_num < less_than){
return(paste("Found a number less than", less_than, "in", i, "iterations."))
}
}
return(paste("did not find a number less than", less_than, "over", max, "iterations."))
}
how_long_to_x()
how_long_to_x()
how_long_to_x()
how_long_to_x()
how_long_to_x()
math1 = function(x){
y=10
return(x * y)
}
#QUESTION: what will the following yield and why?
y = 12
math1(y)
# a: 144
# b: 100
# c: 120
# d: error
#this will work
x = 17
math2 = function(){
y=10
return(x * y)
}
math2()
nested_math = function(y){
x5 = y+3
return(x)
}
math3 = function(){
y = 10
z = nested_math(y)
return(x5 * y)
}
math3()
y = c(1,2,3,4,5,6)
#hidden call to y in this function
vector_math = function(x){
return(x*y)
}
in_dat = c(17, 38, 10)
out1 = vector_math(in_dat)
print(out1)
#say we did something else in our code and overwrite y
y = 7
#if we do not look inside of vector_math, we would assume
#this function should have the same result as when it was run above
out2 = vector_math(in_dat)
out2  # what is going on here?
out1 == out2
#Here I reinvent the wheel and write a function to take the mean of a vector
my_mean = function(x){
count = 0
total = 0
for(n in x){
count = count + 1
total = total + n
}
if(count == 0){
stop("Cannot take the mean of an empty vector!\n")
}else if(count == 1){
warning("Be aware this is the mean of a single number!\n")
}
return(total/count)
}
my_mean(c(3,6,9,10))
#if we later reuse this function, we can avoid all the detail contained within it
my_tri_mean = function(x){
mod = my_mean(x)
out = 3*mod
return(out)
}
my_tri_mean(c(3,6,9,10.5))
#Here I reinvent the wheel and write a function to take the mean of a vector
my_mean = function(x){
count = 0
total = 0
for(n in x){
count = count + 1
total = total + n
}
if(count == 0){
stop("Cannot take the mean of an empty vector!\n")
}else if(count == 1){
warning("Be aware this is the mean of a single number!\n")
}
return(total/count)
}
my_mean(c(3,6,9,10))
z = c()
my_tri_mean(z) #we hit the stop condition here and get an error
x = c(1)
my_tri_mean(x) #this only hits the warning condition, so the function executes but prints a warning of potential trouble
13 -> x
x
contributors()
demo()
#CAM - personally I would pass a vector of names to the read_tsv as opposed to renaming in the pipe.
colnames = c("chr", "source", "feature", "start", "end", "score", "frame", "attribute" )
?read_tsv
#this package is used to load and manipulate the relevant dataframes
#install.packages(tidyverse)
library(tidyverse)
?read_tsv
#I set important filenames etc. to variables, so they can be easily found, changed, and reused.
gff_filename = 'ref_ASM291031v2_top_level.gff3'
ncbi_code_AC08 = 'NC_036848.1'
# all the detail above is abstracted away into this line
AC08 = read_gff(gff_filename, chromosome = ncbi_code_AC08)
# this function takes a .gff or .gff3 file and creates a tibble
# arguments:
# filename -  the name of the gff file
# lead_skip - this argument specifies the
# chromosome - the chromosome to subset from the full gff, default is 'all' and no subset is performed.
read_gff = function(filename, lead_skip = 9, chromosome = "all"){
#CAM - personally I would pass a vector of names to the read_tsv as opposed to renaming in the pipe.
colnames = c("chr", "source", "feature", "start", "end", "score", "frame", "attribute" )
#read in the file with readr
gff = read_tsv(filename, col_names = colnames, skip = lead_skip) %>%
filter(feature == 'gene') %>%
arrange(start, end) %>%
mutate(mid = start + (end-start)/2) ## arrange each gene by its start and end points on each chromosome
if(chromosome != "all"){
sub_gff = gff %>% filter(chr == chromosome)
return(sub_gff)
}
#if the default chr arg was not passed, return full gff
return(gff)
}
# all the detail above is abstracted away into this line
AC08 = read_gff(gff_filename, chromosome = ncbi_code_AC08)
setwd("~/bin/UGRU/matt_snp_work")
#alter this line to the directory on your computer containing the files to be analyzed
setwd("~/bin/UGRU/matt_snp_work")
# all the detail above is abstracted away into this line
AC08 = read_gff(gff_filename, chromosome = ncbi_code_AC08)
#CAM - I don't have this file, so none of the code works for me.
gff = read_tsv('ref_ASM291031v2_top_level.gff3',
## read in the Arctic charr genome data (gff file)
col_names = F,
skip = 9) %>%
## there are 9 garbage lines, need to get rid of them
#CAM - I would pass a list of names to the read_tsv as opposed to renaming in the pipe.
rename(chr = X1,
## Need to rename the columns to something informative
source = X2,
feature = X3,
start = X4,
end = X5,
score = X6,
strand = X7,
frame = X8,
attribute = X9) %>%
filter(feature == 'gene') %>%
## only want the coding gene regions
arrange(start,
end) %>%
## arrange each gene by its start and end points on each chromosome
mutate(mid = start + (end-start)/2)
gff
problems()
# all the detail above is abstracted away into this line
AC08 = read_gff(gff_filename, chromosome = ncbi_code_AC08)
AC08
AC08_out = read_outlier(outlier_data, chromosome = outlier_code_AC08)
read_outlier = function(filename, chromosome = "all"){
out_dat = read_tsv(filename) %>%
arrange(CHROME3) %>%
filter(CHROME3 != 'Contigs')
if(chromosome != "all"){
sub_out = data %>%
filter(CHROME3 == chromosome)
return(sub_out)
}
return(out_dat)
}
AC08_out = read_outlier(outlier_data, chromosome = outlier_code_AC08)
outlier_data = "PCAdapt_lake_outliers.txt"
outlier_code_AC08 = "AC08"
AC08_out = read_outlier(outlier_data, chromosome = outlier_code_AC08)
read_outlier = function(filename, chromosome = "all"){
out_dat = read_tsv(filename) %>%
arrange(CHROME3) %>%
filter(CHROME3 != 'Contigs')
if(chromosome != "all"){
sub_out = out_dat %>%
filter(CHROME3 == chromosome)
return(sub_out)
}
return(out_dat)
}
AC08_out = read_outlier(outlier_data, chromosome = outlier_code_AC08)
AC08_out
#
pos = AC08_out$PDIST.x
pos
gene_regions = AC08 %>%
mutate(hit_dist = abs(mid - pos)) %>%
arrange(hit_dist) %>%
filter(hit_dist <5000) %>%
select(chr, start, end, attribute, hit_dist) %>%
pull(attribute)
gene_regions
library(patchwork)
#install.packages('janitor')
library(janitor)
#install.packages('devtools')
library(devtools)
#install.packages('skimr')
library(skimr)
#install.packages('rsed')
library(rsed)
#install.packages('data.table')
library(data.table)
#install.packages('tidyverse')
library(tidyverse)
#CAM - ?why is this here?
theme_set(theme_bw())
#CAM - I don't have this file, so none of the code works for me.
gff = read_tsv('ref_ASM291031v2_top_level.gff3',
## read in the Arctic charr genome data (gff file)
col_names = F,
skip = 9) %>%
## there are 9 garbage lines, need to get rid of them
#CAM - I would pass a list of names to the read_tsv as opposed to renaming in the pipe.
rename(chr = X1,
## Need to rename the columns to something informative
source = X2,
feature = X3,
start = X4,
end = X5,
score = X6,
strand = X7,
frame = X8,
attribute = X9) %>%
filter(feature == 'gene') %>%
## only want the coding gene regions
arrange(start,
end) %>%
## arrange each gene by its start and end points on each chromosome
mutate(mid = start + (end-start)/2)
# Our SNP data ------------------------------------------------------------
data = read_tsv('PCAdapt_lake_outliers.txt') %>% #CAM -there are trailing whitespaces everywhere
## read in the dataframe of outlier loci within the population
arrange(CHROME3) %>%
## Arrange the df by chromosome number
filter(CHROME3 != 'Contigs')
AC08 = gff %>%
filter(chr == 'NC_036848.1')
AC08_out = data %>%
filter(CHROME3 == 'AC08')
pos = AC08_out$PDIST.x
gene_regions = AC08 %>%
mutate(hit_dist = abs(mid - pos)) %>%
## find the distance between the mid point and the snp position
arrange(hit_dist) %>%
## arrange by hit distance
filter(hit_dist <5000) %>%
## lets find genes within 5kb of our snps
select(chr,
start,
end,
attribute,
hit_dist) %>%
## select the data that we need
pull(attribute)
gene_regions
read_outlier = function(filename, chromosome = "all"){
out_dat = read_tsv(filename) %>%
arrange(CHROME3) %>%
filter(CHROME3 != 'Contigs')
if(chromosome != "all"){
sub_out = out_dat %>%
filter(CHROME3 == chromosome)
return(sub_out)
}
return(out_dat)
}
# this function takes a .gff or .gff3 file and creates a tibble
# arguments:
# filename -  the name of the gff file
# lead_skip - this argument specifies the
# chromosome - the chromosome to subset from the full gff, default is 'all' and no subset is performed.
read_gff = function(filename, lead_skip = 9, chromosome = "all"){
#CAM - personally I would pass a vector of names to the read_tsv as opposed to renaming in the pipe.
colnames = c("chr", "source", "feature", "start", "end", "score", "frame", "attribute" )
#read in the file with readr
gff = read_tsv(filename, col_names = colnames, skip = lead_skip) %>%
filter(feature == 'gene') %>%
arrange(start, end) %>%
mutate(mid = start + (end-start)/2) ## arrange each gene by its start and end points on each chromosome
if(chromosome != "all"){
sub_gff = gff %>% filter(chr == chromosome)
return(sub_gff)
}
#if the default chr arg was not passed, return full gff
return(gff)
}
read_outlier = function(filename, chromosome = "all"){
out_dat = read_tsv(filename) %>%
arrange(CHROME3) %>%
filter(CHROME3 != 'Contigs')
if(chromosome != "all"){
sub_out = out_dat %>%
filter(CHROME3 == chromosome)
return(sub_out)
}
return(out_dat)
}
gff_filename = "ref_ASM291031v2_top_level.gff3"
ncbi_code_AC08 = "NC_036848.1"
outlier_data = "PCAdapt_lake_outliers.txt"
outlier_code_AC08 = "AC08"
# all the detail above is abstracted away into these two lines
AC08 = read_gff(gff_filename, chromosome = ncbi_code_AC08)
AC08_out = read_outlier(outlier_data, chromosome = outlier_code_AC08)
# obtain outlier positions
pos = AC08_out$PDIST.x
gene_regions = AC08 %>%
mutate(hit_dist = abs(mid - pos)) %>%
arrange(hit_dist) %>%
filter(hit_dist <5000) %>%
select(chr, start, end, attribute, hit_dist) %>%
pull(attribute)
gene_regions
gene_regions = AC08 %>%
mutate(hit_dist = abs(mid - pos)) %>%
## find the distance between the mid point and the snp position
arrange(hit_dist) %>%
## arrange by hit distance
filter(hit_dist <5000) %>%
## lets find genes within 5kb of our snps
select(chr,
start,
end,
attribute,
hit_dist) %>%
## select the data that we need
pull(attribute)
gene_regions
# all the detail above is abstracted away into these two lines
cAC08 = read_gff(gff_filename, chromosome = ncbi_code_AC08)
cAC08_out = read_outlier(outlier_data, chromosome = outlier_code_AC08)
gff = read_tsv('ref_ASM291031v2_top_level.gff3',
## read in the Arctic charr genome data (gff file)
col_names = F,
skip = 9) %>%
## there are 9 garbage lines, need to get rid of them
#CAM - I would pass a list of names to the read_tsv as opposed to renaming in the pipe.
rename(chr = X1,
## Need to rename the columns to something informative
source = X2,
feature = X3,
start = X4,
end = X5,
score = X6,
strand = X7,
frame = X8,
attribute = X9) %>%
filter(feature == 'gene') %>%
## only want the coding gene regions
arrange(start,
end) %>%
## arrange each gene by its start and end points on each chromosome
mutate(mid = start + (end-start)/2)
#CAM - ^ put space between infix
## calculate the mid point of each gene from the start and end points
# Our SNP data ------------------------------------------------------------
data = read_tsv('PCAdapt_lake_outliers.txt') %>% #CAM -there are trailing whitespaces everywhere
## read in the dataframe of outlier loci within the population
arrange(CHROME3) %>%
## Arrange the df by chromosome number
filter(CHROME3 != 'Contigs')
AC08 = gff %>%
filter(chr == 'NC_036848.1')
AC08_out = data %>%
filter(CHROME3 == 'AC08')
pos = AC08_out$PDIST.x
AC08_out == cAC08_out
AC08_out
cAC08_out
all.equal(cAC08, AC08)
cAC08_out
AC08_out
cAC08
AC08
cAC08
names(cAC08) == names(AC08)
# this function takes a .gff or .gff3 file and creates a tibble
# arguments:
# filename -  the name of the gff file
# lead_skip - this argument specifies the
# chromosome - the chromosome to subset from the full gff, default is 'all' and no subset is performed.
read_gff = function(filename, lead_skip = 9, chromosome = "all"){
#CAM - personally I would pass a vector of names to the read_tsv as opposed to renaming in the pipe.
colnames = c("chr", "source", "feature", "start", "end", "score", "strand", "frame", "attribute" )
#read in the file with readr
gff = read_tsv(filename, col_names = colnames, skip = lead_skip) %>%
filter(feature == 'gene') %>%
arrange(start, end) %>%
mutate(mid = start + (end-start)/2) ## arrange each gene by its start and end points on each chromosome
if(chromosome != "all"){
sub_gff = gff %>% filter(chr == chromosome)
return(sub_gff)
}
#if the default chr arg was not passed, return full gff
return(gff)
}
read_outlier = function(filename, chromosome = "all"){
out_dat = read_tsv(filename) %>%
arrange(CHROME3) %>%
filter(CHROME3 != 'Contigs')
if(chromosome != "all"){
sub_out = out_dat %>%
filter(CHROME3 == chromosome)
return(sub_out)
}
return(out_dat)
}
#I set important filenames etc. to variables, so they can be easily found, changed, and reused.
gff_filename = "ref_ASM291031v2_top_level.gff3"
ncbi_code_AC08 = "NC_036848.1"
outlier_data = "PCAdapt_lake_outliers.txt"
outlier_code_AC08 = "AC08"
# all the detail above is abstracted away into these two lines
AC08 = read_gff(gff_filename, chromosome = ncbi_code_AC08)
AC08_out = read_outlier(outlier_data, chromosome = outlier_code_AC08)
# obtain outlier positions
pos = AC08_out$PDIST.x
gene_regions = AC08 %>%
mutate(hit_dist = abs(mid - pos)) %>%
arrange(hit_dist) %>%
filter(hit_dist <5000) %>%
select(chr, start, end, attribute, hit_dist) %>%
pull(attribute)
gene_regions
?readr
